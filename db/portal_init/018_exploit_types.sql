-- Project Exploit Types persistence (tables, RLS, API view)
-- Follows ID conventions: UUID id (internal), api_id bigserial (external via PostgREST)

-- Base table
CREATE TABLE IF NOT EXISTS public.project_exploit_types (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  api_id bigserial UNIQUE NOT NULL,
  project_id uuid NOT NULL REFERENCES public.projects(id) ON DELETE CASCADE,
  type_abbrev text NOT NULL,
  enabled boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Uniqueness: one row per project and type
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'project_exploit_types_unique'
  ) THEN
    ALTER TABLE public.project_exploit_types
      ADD CONSTRAINT project_exploit_types_unique UNIQUE (project_id, type_abbrev);
  END IF;
END $$;

-- Indexes
CREATE INDEX IF NOT EXISTS project_exploit_types_project_id_idx ON public.project_exploit_types(project_id);
CREATE INDEX IF NOT EXISTS project_exploit_types_type_idx ON public.project_exploit_types(type_abbrev);

-- Updated_at trigger
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'project_exploit_types_set_updated_at') THEN
    CREATE TRIGGER project_exploit_types_set_updated_at BEFORE UPDATE ON public.project_exploit_types FOR EACH ROW EXECUTE PROCEDURE set_updated_at();
  END IF;
END $$;

-- RLS
ALTER TABLE public.project_exploit_types ENABLE ROW LEVEL SECURITY;
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'project_exploit_types' AND policyname = 'sel_project_exploit_types_anon'
  ) THEN
    CREATE POLICY sel_project_exploit_types_anon ON public.project_exploit_types FOR SELECT TO postgrest_anon USING (true);
  END IF;
END $$;
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'project_exploit_types' AND policyname = 'all_project_exploit_types_app'
  ) THEN
    CREATE POLICY all_project_exploit_types_app ON public.project_exploit_types FOR ALL TO app USING (true) WITH CHECK (true);
  END IF;
END $$;

-- API view
CREATE SCHEMA IF NOT EXISTS api;
GRANT USAGE ON SCHEMA api TO postgrest_anon;

CREATE OR REPLACE VIEW api.project_exploit_types AS
  SELECT
    api_id AS id,
    project_id,
    type_abbrev AS type,
    enabled,
    created_at,
    updated_at
  FROM public.project_exploit_types;

GRANT SELECT ON ALL TABLES IN SCHEMA api TO postgrest_anon;

-- RPC: upsert project exploit type (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION api.upsert_project_exploit_type(
  p_project_id uuid,
  p_type text,
  p_enabled boolean
) RETURNS void
LANGUAGE sql
SECURITY DEFINER
AS $$
  INSERT INTO public.project_exploit_types (project_id, type_abbrev, enabled)
  VALUES (p_project_id, p_type, p_enabled)
  ON CONFLICT (project_id, type_abbrev)
  DO UPDATE SET enabled = EXCLUDED.enabled, updated_at = now();
$$;

GRANT EXECUTE ON FUNCTION api.upsert_project_exploit_type(uuid, text, boolean) TO postgrest_anon;
